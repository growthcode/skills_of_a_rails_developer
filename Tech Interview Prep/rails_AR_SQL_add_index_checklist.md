# ` add_index ` checklist and notes

(performance measuring queries in Rails)[http://weblog.rubyonrails.org/2011/12/6/what-s-new-in-edge-rails-explain/]
(blog post on indexing in rails)[http://rny.io/rails/postgresql/2013/08/20/postgresql-indexing-in-rails.html]

(apidock.com)[http://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index]

- **Goal** of indexes is to eliminate the dreaded "table scan" or "file sort" operations that occur when your data is not index properly.
- In simple terms, "Look at the queries being generated by your application and esnsure that the coluns referenced in ` WHERE `, ` HAVING `, and ` ORDER BY ` clauses are represented in that order."

## When to indexes (in Rails migrations):

(indexing)[http://stackoverflow.com/questions/3658859/when-to-add-what-indexes-in-a-table-in-rails/3661096#3661096]

- Always Add Index to:
    - foreign keys
    - whichever way you find/search a record, like if you find_by:
        - :first_name
        - :company_name
        - :age
    - columns you will ` ORDER BY `, i.e. sort
        - default is ` ASC `
        - smart to add an ` :order ` option on the index
            - ` add_index :posts, :released_at, order: { released_at: "DESC NULLS LAST" } `
    - scope search column

- Do not add indexes to:
    - ` id ` column, it's done automatically

- Any Unique Fields?
    - add unique field index on database level
        - ` add_index :users, :username, unique: true `

- Any ` WHERE ` clauses?
    - Add Partial index
        - ` add_index :orders, :billed, where: "billed = false" `

- Multiple field sorting/ordering?
    - Do double or "composite" index.
    - ` index( column_A, column_B, column_C ) `
    - So the above index will also satisfy queries that need
    ```
        index( column_A, column_B, column_C )
        index( column_A, column_B )
        index( column_A )
    ```
        - Notice how column_B is missing.
    - They are expensive on inserts and updates.
    - Second, they are only brought to bear if you are truly searching across nested data









## Notes on indexing
- What is an Index?
    - An index is a specific structure that organizes a reference to your data that makes it easier to look up
    - In Postgres it is a copy of the item you wish to index combined with a reference to the actual data location.
        - When accessing data, Postgres will either use some form of an index if it exists or a sequential scan.
        - A sequential scan is when it searches over all of the data before returning the results.
- Advantages of having an index:
    - Great for accessing your data faster.
- Disadvantages of having an index:
    - Takes up space on the database
    - Must rebuild each index every time there is a ` create ` or ` update `
    - For each index you have you will insert data at a slower pace.
        - when you insert your data with an index it must:
            - write data to two places
            - maintain the sort on the index as you insert data
        - Certain indexes additionally will be more effective than others, such as indexes on numbers or timestamps (text is expensive).
- SQLite doesnâ€™t support index length.
- You can create an index with a method if using PostgresSQL or MySQL, see documentaiton.


## Syntax
- Syntax breakdown ` add_index(table_name, column_name, options = {}) `
    - Adds a new index to the table.
    - ` column_name ` can be a single Symbol, or an Array of Symbols
    - The index will be named after the table and the column name(s), unless you pass :name as an option.

- Creating **Simple** Index:
    - ` add_index :suppliers, :company_name ` or ` add_index(:suppliers, :company_name)` generates:
                - ` CREATE INDEX suppliers_name_index ON suppliers(company_name) `

- Creating an **Unique** Index:
    - Only 1 row in the entire table can have that value.
    - ` add_index(:accounts, [:branch_id, :party_id], unique: true) ` generates:
        - ` CREATE UNIQUE INDEX accounts_branch_id_party_id_index ON accounts(branch_id, party_id) `

- Creating an Index with **specific key length**:
    - ` add_index(:accounts, :name, name: 'by_name', length: 10) ` generates:
        - ` CREATE INDEX by_name ON accounts(name(10)) `
    - ` add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15}) ` generates:
        - CREATE INDEX by_name_surname ON accounts(name(10), surname(15))

- Creating an Index with **a sort order** (desc or asc, asc is the default):
    - ` add_index(:accounts, [:branch_id, :party_id, :surname], order: {branch_id: :desc, party_id: :asc}) ` generates:
        - ` CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname) ` generates:

- See documantation for:
    - Creating a **Partial** Index
    - Creating an Index with **custom method**
